# React: reconcillation

- :newspaper: [React Reconciliation: скрытый механизм, управляющий компонентами | Хабр](https://habr.com/ru/companies/timeweb/articles/901212/)

Основополагающий аспект процесса согласования в React: тип элемента является основным фактором для определения его идентичности.

Дерево JS-объектов с полями children. Если поле `type` изменилось, React перестраивает все поддерево (remount).

Если `key` не задан, а `type` одинаковый, элементы различаются по позиции.

При рендеринге списков React использует ключи, чтобы отслеживать, какие элементы были добавлены, удалены или перемещены.

Без ключей React был бы вынужден полагаться исключительно на позицию элемента в массиве. Если новый элемент вставляется в начало, React воспринимает каждый элемент как изменивший свою позицию и рендерит весь список.

Перенос ключа с элемента одного уровня и типа на другой элемент переносит состояние.

```jsx
{isPrimary ? (
	<UserProfile userId={123} role="primary" />
) : (
	<UserProfile userId={456} role="secondary" />
)}
```

— элемент не перемонтируется, в старый элемент будут переданые новые props.

## Плохие практики

Определение одних компонентов внутри других создает новые ссылки на функции при каждом рендеринге, поле type постоянно меняется и это вызывает remount компонента.

## Использование постоянного ключа с разными типами

```jsx
const TabContent = ({ activeTab }) => {
  // Все вкладки имеет одинаковый ключ, поэтому React сохраняет состояние при переключении между ними
  return (
    <div>
      {activeTab === "profile" && <ProfileTab key="tab-content" />}
      {activeTab === "settings" && <SettingsTab key="tab-content" />}
      {activeTab === "activity" && <ActivityTab key="tab-content" />}
    </div>
  );
};
```

Поскольку ключ явно задан постоянным, React рассматривает это как "тот же компонент изменил свой тип", а не как "один компонент был размонтирован, а другой смонтирован".

Это позволяет эффективно переносить внутреннее состояние от одного компонента к другому. Например, если у компонента `ProfileTab` есть поля ввода с данными, введенными пользователем, эти значения сохраняются при переключении на компонент `SettingsTab` несмотря на то, что это совершенно разные элементы.
