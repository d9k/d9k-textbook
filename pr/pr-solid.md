# Программирование: принципы SOLID

- [SOLID (программирование) — Википедия](https://ru.wikipedia.org/wiki/SOLID_%28программирование%29)
- [SOLID принципы в 2024: Полный разбор и прожарка / S0ER / #12 Организованное Программирование | Мокевнин](https://vkvideo.ru/playlist/-224967259_-13/video-224967259_456239050)

Разработаны Робертом Мартином (Дядя Боб), автором книги "Чистый код" и Agile Manifesto.

## \[S\]ingle responsibility

Одно предназначение для каждого класса. Данные для выполнения этой цели должна быть скрыты (инкапсулированы) в классе.

Классы должны иметь одну и только одну причину для изменений. Представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:

- может измениться само содержимое отчёта;
- может измениться формат отчёта.

SRP говорит, что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна ответственность.

## \[O\]pen–closed

Открытость для расширения - поведение сущности может быть расширено путём создания новых типов сущностей (динамический полиморфизм).

Закрытость для модификации - код, использующий сущность, не должен меняться (интерфейс модуля остаётся прежним, меняется реализация модуля).

\[?\] Однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или изменённые функции требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через механизм наследования.

Примеры:
- Система плагинов в каком-то фреймворке.
- Добавить флажок в класс отчёта - нарушение open/closed принципа. Вместо одного универсального класса презентаторы. Похоже на паттерн Стратегия.
- Система хуков.
- Модель события Smalltalk - обмен сообщениями более соответствует модели открытости/закрытости, чем прямой вызов. Не завязан на получателя. Сообщение проще преодолевает границы.

## \[L\]iskov substitution

Принцип Барбары Лисков.

Функции, использующие базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом

## \[I\]nterface segregation

Слишком «большие» интерфейсы необходимо разделять на более маленькие и специфичные, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.

## \[D\]ependency inversion

- A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
- B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.