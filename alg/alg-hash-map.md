# Algorithms: hash map

## Хэширование

- :tv: [Как работает хэширование | Хэш-функции | Alek OS | YT](https://www.youtube.com/watch?v=xV8USnjKGCU)[КАК РАБОТАЕТ ХЭШИРОВАНИЕ | ХЭШ-ФУНКЦИИ - YouTube](https://www.youtube.com/watch?v=xV8USnjKGCU)

Хэширование - эта преобразование данных любой длины в данные заданной длины. Одинаковые данные на входе должны всегда приводить к абсолютно одинаковому хэшу. Даже изменение данных всего на 1 бит должны приводить к абсолютно разному хэшу. Зная хэш невозможно восстановить исходные данные.

Коллизия - так как результат хэша ограниченного размера, существуют различные входные данные, которые приведут к генерации одного и того же хэша.

4:30 Генерация коллизии за приемлемое время => хэш-функция взломана.

5:30 Хранятся не сами пароли, а их хэши. При воровстве баз паролей достаточно подсунуть коллизию, приводящую к такому же хэшу.

8:00 Семейства криптостойких хэш функций: md- (2,4..5), crc- (1,4..64) , sha- (1,2,3). sha-3 самый криптостойкий

9:00 Проверка целостности информации при передаче данных. CRC-32 проверяет контрольные суммы отправленных пакетов. При недостоверных данных запрашиваем повторную отправку.

10:45 Полином.

15:00 md5 изобретён в 1991 и взломан в 2006-м - 1 минута на поиск коллизии на обычном компьютере.

18:00 sha-1 как и md-5 произошёл от md-4. sha-1 - Google отказался из-за ненадёжности в 2014. sha-2 в ~2.5 раза медленнее sha-1. В подсемейство SHA-2 входят, например, SHA-256 и SHA-512/256. SHA-256 используется в bitcoin и torrent.

20:00 2008 - первые коллизии SHA-2 найдены. Алгоритм keccac был принят за основу sha-3, использован в Ethereum, в 2015-м принят в качестве федерального стандарта обработки информации.

## Хэш-таблица

- :newspaper: [JavaScript: структуры данных и алгоритмы. Часть 2 | aio350 | Хабр](https://habr.com/ru/companies/timeweb/articles/828068/)

## КАК РАБОТАЮТ ХЭШ-ТАБЛИЦЫ | СТРУКТУРЫ ДАННЫХ | Alek OS | YT

- https://www.youtube.com/watch?v=cWbuK7C13HQ

Ключ пропускается через хэш-функцию.

Понимание полезно для анализа скорости своих алгоритмов.

Объекты в JS, массивы в PHP, словари в C# - построены на хэш-таблицах

3:40 Считаем хэш, получаем id другой функцией массива

6:00 Придётся хранить коллизии индексов (по определению вариативность индексов меньше, чем ключей)

6:30 Поэтому храним по индексу не само значение, а связный список коллизий индекса (ключ, значение). При получении/вставке нам придётся просматривать весь связный список и сравнивать хранящиеся там ключ один за другим с оригиналом.

8:50 Реализация getIndex, getHash зависит от типа ключа. Он может быть числом, строкой, массивом, объектом...

9:30 Если мы хотим хэш `int32`, а на вход хэш-функции будет подаваться число `int32`, то мы можем использовать само число `int32` как хэш.

11:30 `getIndex()` можно реализовать просто как остаток от деления на размер массива.

12:20 если в `getIndex()` делитель степень двойки n, то это аналогично забиранию n младших битов хжша

13:30 если взять простое число за делитель коллизий индекса будет меньше. Но простое число нужно взять максимально далеко отстоячее от степеней двойки

14:30 при расчёте хэша строки лучше тоже умножать на простое число. Аналог сдвига на 5 бит влево минус сам хэш. Методом подбора такое число оказалось 31. А это то же самое, что `(hash << 5) - hash`. Ещё стоит не склеивать, а складывать между собой "стыки" байтов при сдвиге.

16:30 хэш-таблица: расширяться (переходить к следующему простому числу `5, 11, 23, 47, 97, 193...`) лучше, когда процент заполненных ячеек 75%.

17:50 Связный список плохо поддаётся кэшированию, т. к. все узлы связного списка раскинуты по оперативной памяти. ***Таблицы с открытой адресацией***: в каждой ячейке по индексу хранится не связный список, а просто одна пара ключ-значение. При коллизии просто переход к следующей незанятой ячейке. В отличии от связного списка при данном подходе для поиска нужно просматривать ячейки до конца или до обнаружения null. Но при удалении элемента мы можем делать ячейке null только если следующая ячейка - null.

19:00 Все коллизии хранятся цепочкой друг за другом. Чтобы это исправить: переменный шаг поиска незанятой ячейки: `(getIndex(key) + (c1 * i + c2 * i^2)) % array_values.length`. Шаг можно высислять другой хэш-функцией `hashStep()`, например ``.

